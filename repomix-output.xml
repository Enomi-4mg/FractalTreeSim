This file is a merged representation of the entire codebase, combined into a single document by Repomix.

<file_summary>
This section contains a summary of this file.

<purpose>
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.
</purpose>

<file_format>
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Repository files (if enabled)
5. Multiple file entries, each consisting of:
  - File path as an attribute
  - Full contents of the file
</file_format>

<usage_guidelines>
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.
</usage_guidelines>

<notes>
- Some files may have been excluded based on .gitignore rules and Repomix's configuration
- Binary files are not included in this packed representation. Please refer to the Repository Structure section for a complete list of file paths, including binary files
- Files matching patterns in .gitignore are excluded
- Files matching default ignore patterns are excluded
- Files are sorted by Git change count (files with more changes are at the bottom)
</notes>

</file_summary>

<directory_structure>
.gitignore
Environment.pde
FractalTreeSim.pde
Ground.pde
Interaction.pde
Tree.pde
Weather.pde
</directory_structure>

<files>
This section contains the contents of the repository's files.

<file path=".gitignore">
.vscode/
</file>

<file path="Environment.pde">
// --- 描画パイプラインのモジュール化 ---

void renderBackground() {
  background(210, 40, 10);
  ambientLight(0, 0, 30);
  directionalLight(0, 0, 80, 0.5, 1, -1); // [cite: 9, 51]
}

float camX = 0, camY = 0, camZoom = 0;

void applyCameraTransform() {
  if (isViewerMode) {
    translate(width/2, height/2, camZoom);
    rotateX(camX);
    rotateY(camY);
    translate(0, 200, 0); // [cite: 53]
  } else {
    translate(width/2, height * 0.9, -200);
    rotateY(frameCount * 0.005); // [cite: 11, 54]
  }
}

void renderGround() {
  pushMatrix();
  rotateX(HALF_PI);
  fill(140, 20, 20);
  noStroke();
  rect(0, 0, 2000, 2000); // [cite: 12, 59]
  
  stroke(140, 20, 30);
  for (int i = -1000; i <= 1000; i += 100) {
    line(i, -1000, i, 1000);
    line(-1000, i, 1000, i); // [cite: 13, 60]
  }
  popMatrix();
}

void drawHUD() {
  hint(DISABLE_DEPTH_TEST);
  fill(255);
  textSize(16);
  text("SIMULATION DAY: " + currentDay + " / " + MAX_DAYS, 30, 40);
  text("CONTROLS: [1] WATER [2] FERTILIZER [3] KOTODAMA | [V] VIEW MODE", 30, 70);
  hint(ENABLE_DEPTH_TEST); // [cite: 14, 15, 66]
}
</file>

<file path="Ground.pde">
class Ground {
    float size = 2000;
    int res = 10; // 分割数（将来的な波形・変形用）
    color gColor;
    
    Ground() {
        // 初期色は緑（HSB: Hue=120付近）
        gColor = color(120, 60, 40); 
    }
    
    void display(float mutation) {
        pushMatrix();
        rotateX(HALF_PI);
        
        // カオス度（mutation）に応じて色を濁らせるなどの拡張が可能
        fill(gColor);
        noStroke();
        
        // 平面の描画
        rectMode(CENTER);
        rect(0, 0, size, size);
        
        // グリッド線の描画（デバッグ・目安用）
        stroke(120, 40, 20, 50);
        float step = size / res;
        for (int i = 0; i <= res; i++) {
            float pos = -size / 2 + i * step;
            line(pos, -size / 2, pos, size / 2);
            line( -size / 2, pos, size / 2, pos);
        }
        popMatrix();
    }
}
</file>

<file path="Weather.pde">
enum WeatherState { SUNNY, RAINY, MOONLIGHT }

class Weather {
    WeatherState currentState = WeatherState.SUNNY;
    
    // 雨のパーティクル用
    int rainCount = 150;
    float[] rainX = new float[rainCount];
    float[] rainY = new float[rainCount];
    
    Weather() {
        for (int i = 0; i < rainCount; i++) {
            rainX[i] = random( -width, width);
            rainY[i] = random( -1000, 0);
        }
    }
    
    void next() {
        int nextIndex = (currentState.ordinal() + 1) % WeatherState.values().length;
        currentState = WeatherState.values()[nextIndex];
    }
    
    void apply() {
        switch(currentState) {
            case SUNNY:
                background(200, 20, 90); // 明るい空
                ambientLight(0, 0, 50);
                directionalLight(0, 0, 100, 0.5, 1, -1);
                break;
            
            case RAINY:
                background(200, 10, 30); // どんよりした空
                ambientLight(0, 0, 20);
                drawRain();
                break;
            
            case MOONLIGHT:
                background(240, 80, 10); // 深い夜空
                ambientLight(240, 50, 15);
                directionalLight(240, 60, 50, -0.5, 1, -0.5); 
                break;
        }
    }
    
    private void drawRain() {
        stroke(200, 10, 80, 150);
        strokeWeight(1);
        for (int i = 0; i < rainCount; i++) {
            line(rainX[i], rainY[i], rainX[i], rainY[i] + 20);
            rainY[i] += 15;
            if (rainY[i] > 500) rainY[i] = -500;
        }
    }

    void setRandom() {
        int randomIndex = int(random(WeatherState.values().length));
        currentState = WeatherState.values()[randomIndex];
    }
}
</file>

<file path="FractalTreeSim.pde">
/**
* 3D Fractal Tree Growth Simulator v3.0 (Refactored)
*/

// --- システム設定定数 ---
final int   MAX_DAYS         = 30;
final int   LIMIT_DEPTH      = 7; 
final float INTERPOLATION    = 0.05f;
final float ZOOM_SENSITIVITY = 30.0f;

// --- コマンド種別 ---
final String CMD_WATER      = "WATER";
final String CMD_FERTILIZER = "FERTILIZER";
final String CMD_KOTODAMA   = "KOTODAMA";

Tree    myTree;
int     currentDay = 1;
boolean isViewerMode = false;

Ground  myGround;
Weather myWeather;

void setup() {
    size(1000, 800, P3D);
    colorMode(HSB, 360, 100, 100);
    surface.setTitle("3D Fractal Tree Simulation");
    surface.setLocation(5,5);
    
    myTree = new Tree();
    myGround = new Ground(); 
    myWeather = new Weather();
}

void draw() {
    renderBackground();
    
    myWeather.apply();
    
    pushMatrix();
    applyCameraTransform();
    
    myGround.display(myTree.bMutation);
    myTree.update();  
    myTree.display(); 
    popMatrix();
    
    if (!isViewerMode) drawHUD();
}
</file>

<file path="Interaction.pde">
void keyPressed() {
    if (key == 'v' || key == 'V') {
        isViewerMode = !isViewerMode;
        return;
    }
    
    if (currentDay >= MAX_DAYS) return;
    
    // 現在の天候を保持
    WeatherState ws = myWeather.currentState;
    
    boolean acted = false;
    if (key == '1') {
        myTree.grow(CMD_WATER, ws);
        acted = true;
    } else if (key == '2') {
        myTree.grow(CMD_FERTILIZER, ws);
        acted = true;
    } else if (key == '3') {
        myTree.grow(CMD_KOTODAMA, ws);
        acted = true;
    }
    
    if (acted) {
        currentDay++;
        myWeather.setRandom();
    }
}

void mouseDragged() {
    if (isViewerMode) {
        camY += (mouseX - pmouseX) * 0.01;
        camX -= (mouseY - pmouseY) * 0.01;
    }
}

void mouseWheel(MouseEvent event) {
    if (isViewerMode) {
        camZoom -= event.getCount() * ZOOM_SENSITIVITY;
        camZoom = constrain(camZoom, -3000, 600);
    }
}
</file>

<file path="Tree.pde">
class Tree {
    //--- 描画パラメータ ---
    float bLen = 100, bThick = 20, bAngle = PI / 12;
    float bHue = 140, lSize = 10, lHue = 120;
    int   currentDepth = 2;
    
    //--- カオス・開花パラメータ ---
    float bMutation = 0, tMutation = 0;
    float mutationCurve = 1.5;
    boolean isBloomed = false;
    float bloomFactor = 0;
    final float BLOOM_THRESHOLD = 150.0;
    int STAGE_3_START = 21;
    
    //Lerp目標値
    float tLen, tThick, tAngle, tHue, tLSize;
    PShape leafModel, flowerModel;
    
    Tree() {
        initTargets();
        createLeafModel();
        createFlowerModel();
    }
    
    private void initTargets() {
        tLen = bLen; tThick = bThick; tAngle = bAngle;
        tHue = bHue; tLSize = lSize;
    }
    
    //--- 成長・変異管理 ---
    void grow(String type, WeatherState currentWs) {
        float boost = map(currentDay, 1, MAX_DAYS, 1.0, 2.5);
        float weatherBonus = 1.5;
        
        if (type.equals(CMD_WATER)) {
            //晴（SUNNY）ならバフ
            float currentBoost = (currentWs == WeatherState.SUNNY) ? boost * weatherBonus : boost;
            applyWaterEffect(currentBoost);
        } 
        else if (type.equals(CMD_FERTILIZER)) {
            //雨（RAINY）ならバフ
            float currentBoost = (currentWs == WeatherState.RAINY) ? boost * weatherBonus : boost;
            applyFertilizerEffect(currentBoost);
        } 
        else if (type.equals(CMD_KOTODAMA)) {
            //月夜（MOONLIGHT）ならバフ
            float currentBoost = (currentWs == WeatherState.MOONLIGHT) ? boost * weatherBonus : boost;
            applyKotodamaEffect(currentBoost);
        }
        
        tAngle = constrain(tAngle, 0, PI / 4);
        checkBloomCondition();
    }
    
    private void applyWaterEffect(float boost) {
        tLen += 15 * boost;
        tThick *= 0.98;
        tLSize += 3 * boost;
        tAngle += 0.02 * boost;
        bloomFactor += 5 * boost;
        tMutation = max(0, tMutation - 0.08);
    }
    
    private void applyFertilizerEffect(float boost) {
        tThick += 8 * boost;
        if (currentDepth < LIMIT_DEPTH) currentDepth++;
        bloomFactor += 20 * boost;
        tMutation = max(0, tMutation - 0.06);
    }
    
    private void applyKotodamaEffect(float boost) {
        tHue = (tHue + 60) % 360;
        bloomFactor -= 15 * boost;
        tMutation += 0.2 * boost;
    }
    
    void update() {
        bLen = lerp(bLen, tLen, INTERPOLATION);
        bThick = lerp(bThick, tThick, INTERPOLATION);
        bAngle = lerp(bAngle, tAngle, INTERPOLATION);
        bHue = lerp(bHue, tHue, INTERPOLATION);
        lSize = lerp(lSize, tLSize, INTERPOLATION);
        bMutation = lerp(bMutation, tMutation, INTERPOLATION);
    }
    
    //--- 描画コア ---
    void display() {
        recursiveDraw(bLen, bThick, currentDepth);
    }
    
    private void recursiveDraw(float len, float thick, int depth) {
        if (depth <= 0) return;
        
        // 枝の描画
        drawStem(thick, thick * 0.7, len, depth);
        
        // 葉または花の描画（先端付近のみ）
        if (depth <= 2) {
            if (isBloomed) drawFlowers(len, thick, depth);
            else drawLeaves(len, thick, depth);
        }
        
        translate(0, -len, 0);
        
        // 分岐計算
        int branches = (depth <= 3) ? 2 : 3;
        float wind = map(noise(frameCount * 0.01, depth), 0, 1, -0.05, 0.05);
        
        for (int i = 0; i < branches; i++) {
            pushMatrix();
            rotateY((branches == 2) ? (PI * i) : (TWO_PI / 3 * i));
            rotateZ(bAngle + wind);
            recursiveDraw(len * 0.8, thick * 0.65, depth - 1);
            popMatrix();
        }
    }
    
    private void drawStem(float r1, float r2, float h, int depth) {
        float ratio = pow(constrain(bMutation, 0, 1.0), mutationCurve);
        int segments = 5; 
        
        beginShape(QUAD_STRIP);
        for (int i = 0; i <= segments; i++) {
            float angle = i * TWO_PI / segments;
            fill(calcMutationColor(angle, depth, ratio, false));
            vertex(cos(angle) * r1, 0, sin(angle) * r1);
            
            fill(calcMutationColor(angle, depth, ratio, true));
            vertex(cos(angle) * r2, -h, sin(angle) * r2);
        }
        endShape();
    }
    
    //変異度に応じた色計算の抽出
    private color calcMutationColor(float angle, int depth, float ratio, boolean isTop) {
        float baseH = 25, baseS = 40, baseB = 40 + (currentDepth - depth) * 10;
        
        float hueOffset = sin(frameCount * 0.05 + depth * 0.5) * 60;
        float stripe = sin(angle * 1.5 + frameCount * 0.1) * 30;
        
        float chaosH = (bHue + hueOffset + stripe) % 360;
        float chaosB = 30 + (currentDepth - depth) * 15 + (bMutation * 40);
        
        float finalH = lerp(baseH, chaosH, ratio);
        if (isTop) finalH = (finalH + 10 * ratio) % 360;
        
        return color(finalH, lerp(baseS, 90, ratio), lerp(baseB, chaosB, ratio));
    }
    
    //--- モデル生成・判定 ---
    private void checkBloomCondition() {
        if (currentDay == STAGE_3_START && !isBloomed && bloomFactor >= BLOOM_THRESHOLD) {
            isBloomed = true;
        }
    }
    
    
    private void createLeafModel() {
        leafModel = createShape();
        leafModel.beginShape();
        leafModel.noStroke();
        leafModel.vertex( -1, 0, 0);
        leafModel.vertex(0, -1.5, 0.2);
        leafModel.vertex(1, 0, 0);
        leafModel.vertex(0, 0.5, -0.2);
        leafModel.endShape(CLOSE);
        
        leafModel.disableStyle();
    }
    
    //花弁モデルの生成（単純な4枚花弁）
    private void createFlowerModel() {
        flowerModel = createShape(GROUP);
        for (int i = 0; i < 4; i++) {
            PShape petal = createShape();
            petal.beginShape();
            petal.noStroke();
            petal.vertex(0, 0, 0);
            petal.vertex(0.5, -0.8, 0.1);
            petal.vertex(0, -1.2, 0);
            petal.vertex( -0.5, -0.8, -0.1);
            petal.endShape(CLOSE);
            
            petal.disableStyle();
            petal.rotateY(HALF_PI * i);
            flowerModel.addChild(petal);
        }
        flowerModel.disableStyle();
    }
    
    private void drawLeaves(float len, float thick, int depth) {
        // 変化率を適用した比率を算出 (0.0 - 1.0)
        float m = constrain(bMutation, 0, 1.0);
        float ratio = pow(m, mutationCurve);
        
        // Hue: 120 (緑) -> 320 (赤紫)
        float leafH = map(ratio, 0, 1, 120, 320);
        // Saturation: カオス度に合わせて少し鮮やかに
        float leafS = map(ratio, 0, 1, 70, 90);
        
        for (int i = 0; i < 2; i++) {
            pushMatrix();
            rotateY(PI * i);
            translate(thick * 0.5, -len * (0.5 + i * 0.3), 0);
            rotateZ(sin(frameCount * 0.06 + depth) * 0.1);
            scale(lSize);
            fill(leafH, leafS, 80, 200);
            shape(leafModel);
            popMatrix();
        }
    }
    
    //花を描画するメソッド
    private void drawFlowers(float len, float thick, int depth) {
        float m = constrain(bMutation, 0, 1.0);
        float ratio = pow(m, mutationCurve);
        
        // Hue: 60 (黄) -> 280 (紫)
        float flowerH = map(ratio, 0, 1, 60, 280);
        // Brightness: 100 (明) -> 20 (暗/黒)
        float flowerB = map(ratio, 0, 1, 100, 20);
        // Saturation: 黒紫に近づくほど濃く
        float flowerS = map(ratio, 0, 1, 80, 100);
        for (int i = 0; i < 2; i++) {
            pushMatrix();
            rotateY(PI * i);
            translate(thick * 0.6, -len * 0.8, 0); // 枝の先端寄りに配置
            scale(lSize * 1.5); // 葉より少し大きく
            fill(flowerH, flowerS, flowerB, 220); // 補色に近い色で花を表現
            shape(flowerModel);
            popMatrix();
        }
    }
}
</file>

</files>
